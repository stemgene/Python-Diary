# Graph-based基于图的模型

用户行为很容易用二分图表示，因此很多图的算法都可以用到推荐系统中。

## 用户行为数据的二分图表示

用户行为数据是由一系列二元组组成的，其中每个二元组\(u, i\)表示用户u对物品i产生过行为，这种数据集很容易用一个二分图表示

![](../.gitbook/assets/image%20%2852%29.png)

## 基于图的推荐算法

给用户u推荐物品的任务转化为度量用户顶点 $$v_u$$ 和与 $$v_u$$没有边相连接的物品节点在图上的相关性，相关性越高的物品在推荐列表中的权重就越高。

顶点相关性主要取决于：

* 两个顶点之间的路径数。如有很多路径相连，则相关性高
* 两个顶点之间路径的长度。长度比较短的相关性高
* 两个顶点之间路径经过的顶点。如果不会经过出度比较大的点则相关性高。 

![](../.gitbook/assets/image%20%2866%29.png)

上图中，用户A和物品c、e没有**边**相连，但A和c有一条长度为3的路径相连（A-d-D-c）、e分别有两条长度为3的**路径**相连（A-d-D-e和A-b-C-e），则A与e之间的相关性要高于A与c，因而e在用户A的推荐列表中应该排在物品c之前。另外路径（A-d-D-e）路径经过顶点的出度为（3,2,3,2），（A-b-C-e）的出度为（3,2,2,2），（A-d-D-e）经过一个出度比较大的顶点D，所以（A-d-D-e）对A与e之间的相关性的贡献要小于（A-b-C-e）。

### 随机游走的PersonalRank算法：

假设要给u客户进行个性化推荐，可以从u对应的节点 $$v_u$$开始在用户物品二分图上进行随机游走，到任何一个节点时，首先按照概率alpha决定是否继续游走，还是停止此次游走并再次从$$v_u$$开始下一次游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。

![](../.gitbook/assets/image%20%2849%29.png)

![](../.gitbook/assets/image%20%2864%29.png)

![](../.gitbook/assets/image%20%2857%29.png)

给上图中A用户进行推荐。下图给出了不同迭代次数后每个顶点的访问概率。从图中可以看到，每个顶点的访问概率在9次迭代之后就基本上收敛了。在这个例子中，用户A没有对物品b、d有过行为。在最后的迭代结果中，d的访问概率大于b，因此给A的推荐列表就是{_d_, _b_}。

![](../.gitbook/assets/image%20%2844%29.png)

该算法在**时间复杂度上有明显的缺点**。因为在为每个用户进行推荐时，都需要在整个用户物品二分图上进行迭代，直到整个图上的每个顶点的PR值收敛。这一过程的时间复杂度非常高

解决方案：减少迭代次数和利用矩阵重新设计算法

令M为二分图的转移概率矩阵 $$M(v, v')=\frac{1}{|out(v)|}$$，则迭代公式为 $$r=(1-\alpha)r_0+\alpha M^Tr=(1-\alpha)(1-\alpha M^T)^{-1}r_0$$ ，只需要计算一次稀疏矩阵 $$(1-\alpha M^T)$$ 的求逆。

## 


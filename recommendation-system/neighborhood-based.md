# Neighborhood-based collaborative filtering

## 基于user的协同过滤算法collaborative filtering

当用户对一件物品有过行为（赞或顶、踩，购买等），可以找到其他也有过相同行为的其他用户，然后给他推荐那些人最近有过行为的物品。

### 基础算法：

1. 找到和目标用户兴趣相似的用户集合，即计算两个用户的兴趣相似度。令N\(u\)和N\(v\)代表u和v两个用户曾有过正反馈的物品集合。通过**Jaccard距离** $$w_{uv}=\frac{|N(u)\bigcap{N(v)}|}{|N(u)\bigcup{N(v)}|}$$或**余弦距离**$$w_{uv}=\frac{|N(u)\bigcap{N(v)}|}{\sqrt{|N(u)||N(v)|}}$$计算兴趣相似度。比如A对物品{a, b, d}有过行为，B对物品{a,c}有过行为，利用余弦相似度可以算出$$w_{AB}=\frac{|{a,b,d}\bigcap{{a,c}}|}{\sqrt{|a,b,d||a,c|}}=\frac{1}{\sqrt{6}}$$**，**同理可以算出两两用户之间的相似度。但这种方法的时间复杂度是O\(\|U\|\*\|U\|\)，很耗时，而且很多情况下结果是0。所以换个思路，先计算出 $$|N(u)\bigcap{N(v)}|\neq0$$的用户对\(u,v\)再计算其相似度。**便捷的算法：**先建立物品到用户的倒排表，对于每个用户都保存对该物品产生过行为的用户。针对物品对应的用户建立稀疏矩阵W（两个用户的位置是1，其他位置为0），W就是余弦相似度中的分子部分，然后将W/分母可以得到最终的用户兴趣相似度。
2. 找到这个集合中其他用户喜欢的，且目标用户没有听说过的物品推荐给目标客户。利用**UserCF算法**给用户推荐和他兴趣最相似的K个用户喜欢的物品。 $$p(u,i)=\sum_{v\in{S(u,K)}\bigcap{N(i)}}{w_{uv}r_{vi}}$$ 其中 $$S(u,K)$$包含和用户u兴趣最接近的K个用户，N\(i\)是对物品i有过行为的用户集合， $$w_{uv}$$是u和v的兴趣相似度， $$r_{uv}$$代表用户v对物品i的兴趣，因为使用的是但一行为的隐反馈数据，所以所有的$$r_{uv}=1$$。利用算法，选择合适的K，就可以算出用户A对物品c的兴趣 $$p(A,c)=w_{AB}+w_{AD}=0.74$$，以此类推。

![](../.gitbook/assets/image%20%2846%29.png)

### 基础算法的性能评估

用Random和MostPopular两种非个性化的推荐算法的性能作为基准。**Random**是每次随机挑选10个用户没有产生过行为的物品推荐给当前用户，**MostPoplular**是按物品的流行度给用户推荐他还没有产生行为的物品中最热门的10个物品。后者的precision和recall远高于Random，但coverage非常低，流行度较高。

![](../.gitbook/assets/image%20%2848%29.png)

针对不同的K，测量出算法的性能，对比上图，UserCF的precision和recall都有大幅提高，coverage也非常高，流行度持平。而且针对不同的K，结果会有影响。

![](../.gitbook/assets/image%20%2847%29.png)

* 精度指标Precision和recall。不和K成线性关系。而且对K也不是特别敏感，只要选在一定区域内，精度都不错。
* 流行度。K越大，流行度越好，物品越热门。因为参考人数越多，结果越趋近全局热门
* Coverage。K越大，coverage越低，因为随着流行度增加，越倾向热门物品，长尾物品的推荐就越来越少。

### 用户相似度算法改进

两个用户都对热门物品有反馈并不代表他们兴趣相似，反而如果两个用户对冷门物品有同样行为更能说明他们的兴趣相似度。因此用新的算法：

![](../.gitbook/assets/image%20%2843%29.png)

公式中通过 $$\frac{1}{log1+|N(i)|}$$ 惩罚用户u和v共同兴趣列表中热门物品对他们相似度的影响

![&#x5F53;K=80, UserCF-IIF&#x7565;&#x4F18;](../.gitbook/assets/image%20%2842%29.png)

### 此类算法的问题

用户数庞大，相似度矩阵时间空间复杂度增长为平方关系。很难对推荐结果作出解释。

## 基于item的collaborative filtering算法

ItemCF算法通过分析用户的行为记录计算物品之间的相似度，而不是利用物品自身的属性计算。即Customers who boght this item also bought...从而很好的为推荐结果提供解释。

### 基础算法

1. 计算物品之间的相似度。如果两个物品属于一个用户的兴趣列表，这两个物品可能属于有限的几个领域；如果两个物品属于很多用户的兴趣列表，他们有可能属于同一个领域，因而有很大的相似度。

   * 推荐出热门物品的物品相似度，即 $$w_{ij}$$趋近为1。喜欢物品i的用户中有多少比例的用户也喜欢物品j：$$w_{ij}=\frac{|N(i)\bigcap{N(j)}|}{|N(i)|}$$，分母\|N\(i\)\|是喜欢物品i的用户数，而分子 $$|N(i)\bigcap{N(j)}|$$是同时喜欢物品i和j的用户数。
   * 致力于挖掘长尾信息，此时物品相似度应为$$w_{ij}=\frac{|N(i)\bigcap{N(j)}|}{\sqrt{|N(i)||N(j)|}}$$，此公式惩罚了物品j的权重，因此减轻了热门物品和很多物品相似的可能性。

   首先建立用户-物品倒排表，即对每个用户建立一个包含他喜欢物品的列表，然后对于每个用户，将他物品列表中的物品两两的共现矩阵C中+1

2. 根据物品相似度和用户的历史行为给用户生成推荐列表

![](../.gitbook/assets/image%20%2854%29.png)

得到物品之间的相似度之后，itemCF通过公式计算用户u对一个物品j的兴趣, 即和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。$$p(u,j)=\sum_{v\in{S(j,K)}\bigcap{N(u)}}{w_{ji}r_{ui}}$$，N\(u\)是用户喜欢的物品的集合，S\(j,K\)是和物品j最相似的K个物品的集合， $$w_{ji}$$ 是物品j和i的相似度， $$r_{ui}$$ 是用户u对物品i的兴趣。（对于隐反馈数据机，如果用户u对物品i有过行为，即可令$$r_{ui}=1$$）

![](../.gitbook/assets/image%20%2850%29.png)

用户喜欢《C++Primer》兴趣度1.3和《编程之美》兴趣度0.9，两本书。ItemCF会为这本书分别找出和它们最相似的3本书，然后计算用户对每本书的感兴趣程度。如《算法导论》这本书和《C++Primer》相似度为0.4，和《编程之美》相似度为0.5。这本书对用户的兴趣度就是1.3\*0.4+0.9\*0.5=0.97。

### 基础算法的性能评估

![](../.gitbook/assets/image%20%2853%29.png)




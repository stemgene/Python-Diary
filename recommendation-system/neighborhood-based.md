# Neighborhood-based

## 基于用户的协同过滤算法

### 基础算法：

1. 找到和目标用户兴趣相似的用户集合，即计算两个用户的兴趣相似度。令N\(u\)和N\(v\)代表u和v两个用户曾有过正反馈的物品集合。通过**Jaccard距离** $$w_{uv}=\frac{|N(u)\bigcap{N(v)}|}{|N(u)\bigcup{N(v)}|}$$或**余弦距离**$$w_{uv}=\frac{|N(u)\bigcap{N(v)}|}{\sqrt{|N(u)||N(v)|}}$$计算兴趣相似度。比如A对物品{a, b, d}有过行为，B对物品{a,c}有过行为，利用余弦相似度可以算出$$w_{AB}=\frac{|{a,b,d}\bigcap{{a,c}}|}{\sqrt{|a,b,d||a,c|}}=\frac{1}{\sqrt{6}}$$**，**同理可以算出两两用户之间的相似度。但这种方法的时间复杂度是O\(\|U\|\*\|U\|\)，很耗时，而且很多情况下结果是0。所以换个思路，先计算出 $$|N(u)\bigcap{N(v)}|\neq0$$的用户对\(u,v\)再计算其相似度。**便捷的算法：**先建立物品到用户的倒排表，对于每个用户都保存对该物品产生过行为的用户。针对物品对应的用户建立稀疏矩阵W（两个用户的位置是1，其他位置为0），W就是余弦相似度中的分子部分，然后将W/分母可以得到最终的用户兴趣相似度。
2. 找到这个集合中其他用户喜欢的，且目标用户没有听说过的物品推荐给目标客户。利用**UserCF算法**给用户推荐和他兴趣最相似的K个用户喜欢的物品。 $$p(u,i)=\sum_{v\in{S(u,K)}\bigcap{N(i)}}{w_{uv}r_{vi}}$$ 其中 $$S(u,K)$$包含和用户u兴趣最接近的K个用户，N\(i\)是对物品i有过行为的用户集合， $$w_{uv}$$是u和v的兴趣相似度， $$r_{uv}$$代表用户v对物品i的兴趣，因为使用的是但一行为的隐反馈数据，所以所有的$$r_{uv}=1$$。利用算法，选择合适的K，就可以算出用户A对物品c的兴趣 $$p(A,c)=w_{AB}+w_{AD}=0.74$$，以此类推。

### 基础算法的性能评估

用Random和MostPopular两种非个性化的推荐算法的性能作为基准。**Random**是每次随机挑选10个用户没有产生过行为的物品推荐给当前用户，**MostPoplular**是按物品的流行度给用户推荐他还没有产生行为的物品中最热门的10个物品。后者的precission和recall远高于Random，但coverage非常低，

![](../.gitbook/assets/image%20%2845%29.png)

针对不同的K，测量出算法的性能

![](../.gitbook/assets/image%20%2844%29.png)

